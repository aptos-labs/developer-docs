<a id="0x1_randomness"></a>

# Module `0x1::randomness`

This module provides access to \*instant\* secure randomness generated by the Aptos validators, as documented in
[AIP&#45;41](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-41.md).

Secure randomness means (1) the randomness cannot be predicted ahead of time by validators, developers or users
and (2) the randomness cannot be biased in any way by validators, developers or users.

Security holds under the same proof&#45;of&#45;stake assumption that secures the Aptos network.

- [Resource `PerBlockRandomness`](#0x1_randomness_PerBlockRandomness)
- [Struct `RandomnessGeneratedEvent`](#0x1_randomness_RandomnessGeneratedEvent)
- [Resource `Ghost$var`](#0x1_randomness_Ghost$var)
- [Constants](#@Constants_0)
- [Function `initialize`](#0x1_randomness_initialize)
- [Function `on_new_block`](#0x1_randomness_on_new_block)
- [Function `bytes`](#0x1_randomness_bytes)
- [Function `u8_integer`](#0x1_randomness_u8_integer)
- [Function `u16_integer`](#0x1_randomness_u16_integer)
- [Function `u32_integer`](#0x1_randomness_u32_integer)
- [Function `u64_integer`](#0x1_randomness_u64_integer)
- [Function `u128_integer`](#0x1_randomness_u128_integer)
- [Function `u256_integer`](#0x1_randomness_u256_integer)
- [Function `u8_range`](#0x1_randomness_u8_range)
- [Function `u16_range`](#0x1_randomness_u16_range)
- [Function `u32_range`](#0x1_randomness_u32_range)
- [Function `u64_range`](#0x1_randomness_u64_range)
- [Function `u64_range_internal`](#0x1_randomness_u64_range_internal)
- [Function `u128_range`](#0x1_randomness_u128_range)
- [Function `u256_range`](#0x1_randomness_u256_range)
- [Function `permutation`](#0x1_randomness_permutation)

```move
module 0x1::randomness {
    use 0x1::event;
    use 0x1::hash;
    use 0x1::option;
    use 0x1::system_addresses;
    use 0x1::transaction_context;
    use 0x1::vector;
}
```

<a id="0x1_randomness_PerBlockRandomness"></a>

## Resource `PerBlockRandomness`

32&#45;byte randomness seed unique to every block.
This resource is updated in every block prologue.

```move
module 0x1::randomness {
    struct PerBlockRandomness has drop, key
}
```

<a id="0x1_randomness_RandomnessGeneratedEvent"></a>

## Struct `RandomnessGeneratedEvent`

Event emitted every time a public randomness API in this module is called.

```move
module 0x1::randomness {
    #[event]
    struct RandomnessGeneratedEvent has drop, store
}
```

<a id="0x1_randomness_Ghost$var"></a>

## Resource `Ghost$var`

```move
module 0x1::randomness {
    struct Ghost$var has copy, drop, store, key
}
```

<a id="@Constants_0"></a>

## Constants

<a id="0x1_randomness_MAX_U256"></a>

```move
module 0x1::randomness {
    const MAX_U256: u256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935;
}
```

<a id="0x1_randomness_DST"></a>

```move
module 0x1::randomness {
    const DST: vector<u8> = [65, 80, 84, 79, 83, 95, 82, 65, 78, 68, 79, 77, 78, 69, 83, 83];
}
```

<a id="0x1_randomness_E_API_USE_IS_BIASIBLE"></a>

Randomness APIs calls must originate from a private entry function with
`#[randomness]` annotation. Otherwise, malicious users can bias randomness result.

```move
module 0x1::randomness {
    const E_API_USE_IS_BIASIBLE: u64 = 1;
}
```

<a id="0x1_randomness_initialize"></a>

## Function `initialize`

Called in genesis.move.
Must be called in tests to initialize the `PerBlockRandomness` resource.

```move
module 0x1::randomness {
    public fun initialize(framework: &signer)
}
```

<a id="0x1_randomness_on_new_block"></a>

## Function `on_new_block`

Invoked in block prologues to update the block&#45;level randomness seed.

```move
module 0x1::randomness {
    public(friend) fun on_new_block(vm: &signer, epoch: u64, round: u64, seed_for_new_block: option::Option<vector<u8>>)
}
```

<a id="0x1_randomness_bytes"></a>

## Function `bytes`

Generates a sequence of bytes uniformly at random

```move
module 0x1::randomness {
    public fun bytes(n: u64): vector<u8>
}
```

<a id="0x1_randomness_u8_integer"></a>

## Function `u8_integer`

Generates an u8 uniformly at random.

```move
module 0x1::randomness {
    public fun u8_integer(): u8
}
```

<a id="0x1_randomness_u16_integer"></a>

## Function `u16_integer`

Generates an u16 uniformly at random.

```move
module 0x1::randomness {
    public fun u16_integer(): u16
}
```

<a id="0x1_randomness_u32_integer"></a>

## Function `u32_integer`

Generates an u32 uniformly at random.

```move
module 0x1::randomness {
    public fun u32_integer(): u32
}
```

<a id="0x1_randomness_u64_integer"></a>

## Function `u64_integer`

Generates an u64 uniformly at random.

```move
module 0x1::randomness {
    public fun u64_integer(): u64
}
```

<a id="0x1_randomness_u128_integer"></a>

## Function `u128_integer`

Generates an u128 uniformly at random.

```move
module 0x1::randomness {
    public fun u128_integer(): u128
}
```

<a id="0x1_randomness_u256_integer"></a>

## Function `u256_integer`

Generates a u256 uniformly at random.

```move
module 0x1::randomness {
    public fun u256_integer(): u256
}
```

<a id="0x1_randomness_u8_range"></a>

## Function `u8_range`

Generates a number $n \in [min_incl, max_excl)$ uniformly at random.

NOTE: The uniformity is not perfect, but it can be proved that the bias is negligible.
If you need perfect uniformity, consider implement your own via rejection sampling.

```move
module 0x1::randomness {
    public fun u8_range(min_incl: u8, max_excl: u8): u8
}
```

<a id="0x1_randomness_u16_range"></a>

## Function `u16_range`

Generates a number $n \in [min_incl, max_excl)$ uniformly at random.

NOTE: The uniformity is not perfect, but it can be proved that the bias is negligible.
If you need perfect uniformity, consider implement your own via rejection sampling.

```move
module 0x1::randomness {
    public fun u16_range(min_incl: u16, max_excl: u16): u16
}
```

<a id="0x1_randomness_u32_range"></a>

## Function `u32_range`

Generates a number $n \in [min_incl, max_excl)$ uniformly at random.

NOTE: The uniformity is not perfect, but it can be proved that the bias is negligible.
If you need perfect uniformity, consider implement your own via rejection sampling.

```move
module 0x1::randomness {
    public fun u32_range(min_incl: u32, max_excl: u32): u32
}
```

<a id="0x1_randomness_u64_range"></a>

## Function `u64_range`

Generates a number $n \in [min_incl, max_excl)$ uniformly at random.

NOTE: The uniformity is not perfect, but it can be proved that the bias is negligible.
If you need perfect uniformity, consider implement your own via rejection sampling.

```move
module 0x1::randomness {
    public fun u64_range(min_incl: u64, max_excl: u64): u64
}
```

<a id="0x1_randomness_u64_range_internal"></a>

## Function `u64_range_internal`

```move
module 0x1::randomness {
    public fun u64_range_internal(min_incl: u64, max_excl: u64): u64
}
```

<a id="0x1_randomness_u128_range"></a>

## Function `u128_range`

Generates a number $n \in [min_incl, max_excl)$ uniformly at random.

NOTE: The uniformity is not perfect, but it can be proved that the bias is negligible.
If you need perfect uniformity, consider implement your own via rejection sampling.

```move
module 0x1::randomness {
    public fun u128_range(min_incl: u128, max_excl: u128): u128
}
```

<a id="0x1_randomness_u256_range"></a>

## Function `u256_range`

Generates a number $n \in [min_incl, max_excl)$ uniformly at random.

NOTE: The uniformity is not perfect, but it can be proved that the bias is negligible.
If you need perfect uniformity, consider implement your own with `u256_integer()` &#43; rejection sampling.

```move
module 0x1::randomness {
    public fun u256_range(min_incl: u256, max_excl: u256): u256
}
```

<a id="0x1_randomness_permutation"></a>

## Function `permutation`

Generate a permutation of `[0, 1, ..., n-1]` uniformly at random.
If n is 0, returns the empty vector.

```move
module 0x1::randomness {
    public fun permutation(n: u64): vector<u64>
}
```
