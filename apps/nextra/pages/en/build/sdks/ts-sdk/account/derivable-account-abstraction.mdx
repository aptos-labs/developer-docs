---
title: "Derivable Account Abstraction"
---

import { Steps } from "nextra/components";

# Derivable Account Abstraction

[Derivable Account Abstraction (DAA)]((https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-113.md)) extends the existing [Account Abstraction (AA)](./account-abstraction) framework on Aptos by enabling authentication based on domains.

## Core Concepts

### `FunctionInfo`

A struct defining the authentication function to be invoked.

```move
struct FunctionInfo has copy, drop, store {
    module_address: address,
    module_name: String,
    function_name: String
}
```

The authentication function is responsible for defining the authentication logic using Move. It should return a signer if authentication is successful, otherwise it aborts the transaction.

```move
// The function can return a signer if authentication is successful, otherwise it aborts the transaction.
public fun authenticate(account: signer, auth_data: AbstractionAuthData): signer;
```

### `AccountIdentity`

In Derivable AA, authentication is scoped to a domain. You can register an authentication function, which then creates a domain. The authentication logic is not tied to a specific account but instead relies on the domain and account identity.

Rather than having each user register it's own authentication function, Derivable AA allows for registering a full domain of addresses to be authenticated with same authentication function.
That avoids a need for each account to have a different starting authentication and to need to initialize AA (from it).
This allows providing a more flexible and secure way to manage cross-chain signatures.
This approach also allows for deterministic account address generation based on the `account_identity` and `function_info` of the domain.

### `AbstractionAuthData`

An enum variant defining the authentication data to be passed to the authentication function. It contains:

- `digest`: The sha256 hash of the signing message.
- `abstract_signature`: Abstract bytes that will be passed to the authentication function that will be used to verify the signature.
- `abstract_public_key`: Abstract bytes represents the account identity that will be passed to the authentication function that will be used to verify the transaction.


```move
enum AbstractionAuthData has copy, drop {
  DerivableV1 {
      digest: vector<u8>, // SHA3-256 hash of the signing message
      abstract_signature: vector<u8>, // Custom auth data (e.g., signatures)
      abstract_public_key: vector<u8>, // The account identity
  }
}
```

**Why is the `digest` important?**

The `digest` is checked by the MoveVM to ensure that the signing message of the transaction being submitted is the same as the one presented in the `AbstractionAuthData`. This
is important because it allows the authentication function to verify signatures with respect to the correct transaction.

For example, if you want to permit a public key to sign transactions on behalf of the user, you can permit the public key to sign a transaction with a specific payload.
However, if a malicious user sends a signature for the correct public key but a different payload from the `digest`, the signature will not be valid.


**Example (Move)**

This example demonstrates domain account abstraction using ed25519 hex for signing.

```move
module aptos_experimental::test_derivable_account_abstraction_ed25519_hex {
    use std::error;
    use aptos_std::string_utils;
    use aptos_std::ed25519::{
        Self,
        new_signature_from_bytes,
        new_unvalidated_public_key_from_bytes,
    };
    use aptos_framework::auth_data::AbstractionAuthData;

    const EINVALID_SIGNATURE: u64 = 1;

    /// Authorization function for derivable account abstraction.
    public fun authenticate(account: signer, aa_auth_data: AbstractionAuthData): signer {
    let hex_digest = string_utils::to_string(aa_auth_data.digest());

    let public_key = new_unvalidated_public_key_from_bytes(*aa_auth_data.derivable_abstract_public_key());
    let signature = new_signature_from_bytes(*aa_auth_data.derivable_abstract_signature());
    assert!(
        ed25519::signature_verify_strict(
            &signature,
            &public_key,
            *hex_digest.bytes(),
        ),
        error::permission_denied(EINVALID_SIGNATURE)
    );

    account
    }
}
```

**Example (Typescript)**

```typescript
const derivableAbstractedAccount = new DerivableAbstractedAccount({
  /**
   * The result of the signer function will be available as the `authenticator` field in the `AbstractionAuthData` enum variant.
   */
  signer: (digest) => {
    const hexDigest = new TextEncoder().encode(Hex.fromHexInput(digest).toString());
    return solanaAccount.sign(hexDigest).toUint8Array();
  },
  /**
   * The authentication function to be invoked.
   */
  authenticationFunction: `0x7::test_derivable_account_abstraction_ed25519_hex::authenticate`,
  /**
  * The abstract public key (i.e the account identity)
  */
  abstractPublicKey: account.publicKey.toUint8Array(),
});
```

## Minimal Step-by-Step Guide

<Steps>

### 1. Generate a ED25519 key pair

```ts
const ed25519Account = Account.generate();
```

### 2. Create a DAA

```ts
const daa = new DerivableAbstractedAccount({
  signer: (digest) => {
    // The solana wallet sign function
    const hexDigest = new TextEncoder().encode(Hex.fromHexInput(digest).toString());
    return ed25519Account.sign(hexDigest).toUint8Array();
  },
  authenticationFunction: `0x7::test_derivable_account_abstraction_ed25519_hex::authenticate`,
  abstractPublicKey: ed25519Account.publicKey.toUint8Array(),
});
```

### 3. Fund the DAA to create it on chain

```ts
await aptos.fundAccount({ accountAddress: daa.accountAddress, amount: 1000000 });
```

### 4. Create a recipient account and transfer APT to it

```ts
const recipient = Account.generate();

const pendingTxn = await aptos.transaction.signAndSubmitTransaction({
  signer: daa,
  transaction: await aptos.transferCoinTransaction({
    sender: daa.accountAddress,
    recipient: recipient.accountAddress,
    amount: 100,
  }),
});

const response = await aptos.waitForTransaction({ transactionHash: pendingTxn.hash });
```

</Steps>