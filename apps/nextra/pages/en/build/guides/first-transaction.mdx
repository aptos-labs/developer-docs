---
title: "Your First Transaction"
---

import { Callout, Steps, Tabs } from 'nextra/components'

# Your First Transaction

Transactions are the fundamental way to change data on the Aptos blockchain. Think of them like sending a package: you need to specify what you're sending, who it's going to, and then track it until delivery is confirmed. In blockchain terms, transactions allow you to transfer coins, call smart contract functions, and update on-chain state.

This tutorial will guide you through creating and submitting your first transaction on the Aptos blockchain. You'll learn how to:

1. Set up your development environment
2. Create test accounts and fund them
3. Build a transaction to transfer coins
4. Simulate the transaction to estimate costs
5. Sign and submit the transaction
6. Verify the transaction was executed successfully

<Callout type="info">
This tutorial builds on concepts from the Aptos blockchain. If you're new to blockchain development, don't worry - we'll explain key concepts along the way.
</Callout>

## 1. Setting Up Your Environment

Before we can create transactions, we need to set up our development environment with the necessary tools and SDKs.

<Steps>
### Choose an SDK

Aptos provides SDKs in multiple languages. For this tutorial, you can use either:

- [TypeScript SDK](../sdks/ts-sdk.mdx)
- [Python SDK](../sdks/python-sdk.mdx)

<Callout type="info">
The examples in this tutorial will show both TypeScript and Python implementations.
</Callout>

### Install the SDK

<Tabs items={["TypeScript", "Python"]}>
<Tabs.Tab>

Install the TypeScript SDK using npm, yarn, or pnpm:

```bash filename="Terminal"
npm install @aptos-labs/ts-sdk
# or
yarn add @aptos-labs/ts-sdk
# or
pnpm add @aptos-labs/ts-sdk
```

</Tabs.Tab>
<Tabs.Tab>

Install the Python SDK using pip:

```bash filename="Terminal"
pip install aptos-sdk
```

</Tabs.Tab>
</Tabs>

### Create a project directory

Create a new directory for your project:

```bash filename="Terminal"
mkdir my-first-transaction
cd my-first-transaction
```

### Create a new file

<Tabs items={["TypeScript", "Python"]}>
<Tabs.Tab>

Create a new file named `transaction.ts`:

```bash filename="Terminal"
touch transaction.ts
```

</Tabs.Tab>
<Tabs.Tab>

Create a new file named `transaction.py`:

```bash filename="Terminal"
touch transaction.py
```

</Tabs.Tab>
</Tabs>
</Steps>

## 2. Creating Test Accounts

In blockchain, all transactions must come from an account. Let's create two test accounts: one to send coins (Alice) and one to receive them (Bob).

<Steps>
### Set up the client

First, we need to initialize the Aptos client that will connect to the blockchain:

<Tabs items={["TypeScript", "Python"]}>
<Tabs.Tab>

Open `transaction.ts` in your editor and add:

```ts filename="transaction.ts"
import {
  Account,
  Aptos,
  AptosConfig,
  Network,
} from "@aptos-labs/ts-sdk";

async function main() {
  // Initialize the Aptos client
  const config = new AptosConfig({ network: Network.DEVNET });
  const aptos = new Aptos(config);
  
  console.log("Connected to Aptos devnet");
  
  // More code will go here
}

main().catch(console.error);
```

</Tabs.Tab>
<Tabs.Tab>

Open `transaction.py` in your editor and add:

```python filename="transaction.py"
import asyncio
from aptos_sdk.account import Account
from aptos_sdk.async_client import FaucetClient, RestClient

# Network configuration
NODE_URL = "https://fullnode.devnet.aptoslabs.com/v1"
FAUCET_URL = "https://faucet.devnet.aptoslabs.com"

async def main():
    # Initialize the clients
    rest_client = RestClient(NODE_URL)
    faucet_client = FaucetClient(FAUCET_URL, rest_client)
    
    print("Connected to Aptos devnet")
    
    # More code will go here

if __name__ == "__main__":
    asyncio.run(main())
```

</Tabs.Tab>
</Tabs>

<Callout type="info">
We're connecting to the Aptos devnet, which is a test network where you can experiment without using real coins. The devnet is reset periodically, so don't store anything important there.
</Callout>

### Generate accounts

Now let's create two accounts: Alice (sender) and Bob (receiver):

<Tabs items={["TypeScript", "Python"]}>
<Tabs.Tab>

Add this code inside your `main()` function:

```ts filename="transaction.ts"
// Generate two accounts
const alice = Account.generate();
const bob = Account.generate();

console.log("=== Addresses ===");
console.log(`Alice's address: ${alice.accountAddress}`);
console.log(`Bob's address: ${bob.accountAddress}`);
```

</Tabs.Tab>
<Tabs.Tab>

Add this code inside your `main()` function:

```python filename="transaction.py"
# Generate two accounts
alice = Account.generate()
bob = Account.generate()

print("=== Addresses ===")
print(f"Alice's address: {alice.address()}")
print(f"Bob's address: {bob.address()}")
```

</Tabs.Tab>
</Tabs>

<Callout type="info">
Each account has a unique address (like a bank account number) and a keypair (like your login credentials). The address is derived from the public key, while the private key is kept secret and used for signing transactions.
</Callout>

### Fund the accounts

To perform transactions, accounts need funds. Let's use the faucet to get some test coins:

<Tabs items={["TypeScript", "Python"]}>
<Tabs.Tab>

Add this code after generating the accounts:

```ts filename="transaction.ts"
// Fund the accounts
console.log("\n=== Funding accounts ===");
await aptos.fundAccount({
  accountAddress: alice.accountAddress,
  amount: 100_000_000, // 1 APT = 100,000,000 octas
});
await aptos.fundAccount({
  accountAddress: bob.accountAddress,
  amount: 0, // Bob starts with 0 APT
});
console.log("Accounts funded successfully");

// Check initial balances
const aliceBalance = await aptos.getAccountAPTAmount({
  accountAddress: alice.accountAddress,
});
const bobBalance = await aptos.getAccountAPTAmount({
  accountAddress: bob.accountAddress,
});

console.log("\n=== Initial Balances ===");
console.log(`Alice: ${aliceBalance} octas`);
console.log(`Bob: ${bobBalance} octas`);
```

</Tabs.Tab>
<Tabs.Tab>

Add this code after generating the accounts:

```python filename="transaction.py"
# Fund the accounts
print("\n=== Funding accounts ===")
alice_amount = 100_000_000  # 1 APT = 100,000,000 octas
bob_amount = 0  # Bob starts with 0 APT

await faucet_client.fund_account(alice.address(), alice_amount)
await faucet_client.fund_account(bob.address(), bob_amount)
print("Accounts funded successfully")

# Check initial balances
alice_balance = await rest_client.account_balance(alice.address())
bob_balance = await rest_client.account_balance(bob.address())

print("\n=== Initial Balances ===")
print(f"Alice: {alice_balance} octas")
print(f"Bob: {bob_balance} octas")
```

</Tabs.Tab>
</Tabs>

### Run the code

Let's test our code so far:

<Tabs items={["TypeScript", "Python"]}>
<Tabs.Tab>

```bash filename="Terminal"
npx ts-node transaction.ts
```

You should see output similar to:

```
Connected to Aptos devnet
=== Addresses ===
Alice's address: 0x978c213990c4833df71548df7ce49d54c759d6b6d932de22b24d56060b7af2aa
Bob's address: 0x7af2d6c93a2feafc9b69b5e8ad9d6b513b260f62f23f3a384a3a2e4a84694a9b

=== Funding accounts ===
Accounts funded successfully

=== Initial Balances ===
Alice: 100000000 octas
Bob: 0 octas
```

</Tabs.Tab>
<Tabs.Tab>

```bash filename="Terminal"
python transaction.py
```

You should see output similar to:

```
Connected to Aptos devnet
=== Addresses ===
Alice's address: 0x978c213990c4833df71548df7ce49d54c759d6b6d932de22b24d56060b7af2aa
Bob's address: 0x7af2d6c93a2feafc9b69b5e8ad9d6b513b260f62f23f3a384a3a2e4a84694a9b

=== Funding accounts ===
Accounts funded successfully

=== Initial Balances ===
Alice: 100000000 octas
Bob: 0 octas
```

</Tabs.Tab>
</Tabs>

<Callout type="info">
The addresses you see will be different from the ones shown here, as they are randomly generated each time.
</Callout>
</Steps>

## 3. Building a Transaction

Now that we have funded accounts, let's create a transaction to transfer coins from Alice to Bob. This is like filling out a form specifying what you want to send and to whom.

<Steps>
### Understand transaction structure

A transaction in Aptos has several key components:

1. **Sender**: The account initiating the transaction (Alice)
2. **Function**: The on-chain function to call (in this case, a coin transfer)
3. **Arguments**: Data needed by the function (recipient address and amount)

### Build the transaction

Let's add code to build a transaction that transfers 1000 octas from Alice to Bob:

<Tabs items={["TypeScript", "Python"]}>
<Tabs.Tab>

Add this code to your `main()` function:

```ts filename="transaction.ts"
// 1. Build the transaction
console.log("\n=== 1. Building the transaction ===");
const transaction = await aptos.transaction.build.simple({
  sender: alice.accountAddress,
  data: {
    function: "0x1::aptos_account::transfer",
    functionArguments: [bob.accountAddress, 1000], // Transfer 1000 octas
  },
});
console.log("Transaction built successfully");
```

</Tabs.Tab>
<Tabs.Tab>

Add this to your `main()` function:

```python filename="transaction.py"
from aptos_sdk.transactions import EntryFunction, TransactionPayload, TransactionArgument
from aptos_sdk.bcs import Serializer

# 1. Build the transaction
print("\n=== 1. Building the transaction ===")
payload = EntryFunction.natural(
    "0x1::aptos_account",
    "transfer",
    [],
    [
        TransactionArgument(bob.address(), Serializer.struct),
        TransactionArgument(1000, Serializer.u64),  # Transfer 1000 octas
    ],
)
print("Transaction built successfully")
```

</Tabs.Tab>
</Tabs>

<Callout type="info">
The function `0x1::aptos_account::transfer` is a built-in function in the Aptos framework that transfers coins between accounts. The `0x1` prefix indicates it's part of the core framework.
</Callout>
</Steps>

## 4. Simulating the Transaction

Before submitting a transaction, it's wise to simulate it first to estimate the gas cost. This is like checking shipping costs before sending a package.

<Steps>
### Simulate the transaction

<Tabs items={["TypeScript", "Python"]}>
<Tabs.Tab>

Add this code after building the transaction:

```ts filename="transaction.ts"
// 2. Simulate the transaction
console.log("\n=== 2. Simulating the transaction ===");
const [simulationResult] = await aptos.transaction.simulate.simple({
  signerPublicKey: alice.publicKey,
  transaction,
});

console.log(`Estimated gas units: ${simulationResult.gas_used}`);
console.log(`Estimated gas cost: ${simulationResult.gas_used * simulationResult.gas_unit_price} octas`);
```

</Tabs.Tab>
<Tabs.Tab>

Add this code after building the transaction:

```python filename="transaction.py"
# 2. Simulate the transaction
print("\n=== 2. Simulating the transaction ===")
raw_transaction = await rest_client.create_bcs_transaction(alice, TransactionPayload(payload))
simulation_result = await rest_client.simulate_transaction(raw_transaction, alice)

print(f"Estimated gas units: {simulation_result[0]['gas_used']}")
print(f"Estimated gas cost: {int(simulation_result[0]['gas_used']) * int(simulation_result[0]['gas_unit_price'])} octas")
```

</Tabs.Tab>
</Tabs>

<Callout type="info">
Gas is the computational fee paid to process transactions on the blockchain. The total cost is calculated as `gas_used × gas_unit_price`. Simulation helps you estimate this cost before committing to the transaction.
</Callout>
</Steps>

## 5. Signing and Submitting the Transaction

Now that we've built and simulated the transaction, we need to sign it with Alice's private key and submit it to the blockchain.

<Steps>
### Sign the transaction

Signing proves that Alice authorized this transaction:

<Tabs items={["TypeScript", "Python"]}>
<Tabs.Tab>

Add this code after simulating the transaction:

```ts filename="transaction.ts"
// 3. Sign the transaction
console.log("\n=== 3. Signing the transaction ===");
const senderAuthenticator = aptos.transaction.sign({
  signer: alice,
  transaction,
});
console.log("Transaction signed successfully");
```

</Tabs.Tab>
<Tabs.Tab>

Add this code after simulating the transaction:

```python filename="transaction.py"
# 3. Sign the transaction
print("\n=== 3. Signing the transaction ===")
signed_transaction = await rest_client.create_bcs_signed_transaction(
    alice, TransactionPayload(payload)
)
print("Transaction signed successfully")
```

</Tabs.Tab>
</Tabs>

<Callout type="info">
Digital signatures work like a personal seal or signature in the physical world. They prove that the transaction was authorized by the account owner (who has the private key) and haven't been tampered with.
</Callout>

### Submit the transaction

Now we submit the signed transaction to the blockchain:

<Tabs items={["TypeScript", "Python"]}>
<Tabs.Tab>

Add this code after signing the transaction:

```ts filename="transaction.ts"
// 4. Submit the transaction
console.log("\n=== 4. Submitting the transaction ===");
const pendingTransaction = await aptos.transaction.submit.simple({
  transaction,
  senderAuthenticator,
});
console.log(`Transaction submitted with hash: ${pendingTransaction.hash}`);
```

</Tabs.Tab>
<Tabs.Tab>

Add this code after signing the transaction:

```python filename="transaction.py"
# 4. Submit the transaction
print("\n=== 4. Submitting the transaction ===")
tx_hash = await rest_client.submit_bcs_transaction(signed_transaction)
print(f"Transaction submitted with hash: {tx_hash}")
```

</Tabs.Tab>
</Tabs>

<Callout type="info">
The transaction hash is a unique identifier for your transaction, similar to a tracking number for a package. You can use it to check the status of your transaction.
</Callout>
</Steps>

## 6. Waiting for Confirmation

After submitting a transaction, we need to wait for it to be processed by the blockchain. This is like waiting for a package to be delivered.

<Steps>
### Wait for transaction completion

<Tabs items={["TypeScript", "Python"]}>
<Tabs.Tab>

Add this code after submitting the transaction:

```ts filename="transaction.ts"
// 5. Wait for the transaction to complete
console.log("\n=== 5. Waiting for transaction completion ===");
const txnResult = await aptos.waitForTransaction({
  transactionHash: pendingTransaction.hash,
});
console.log(`Transaction completed with status: ${txnResult.success ? "SUCCESS" : "FAILURE"}`);
```

</Tabs.Tab>
<Tabs.Tab>

Add this code after submitting the transaction:

```python filename="transaction.py"
# 5. Wait for the transaction to complete
print("\n=== 5. Waiting for transaction completion ===")
await rest_client.wait_for_transaction(tx_hash)
print("Transaction completed successfully")
```

</Tabs.Tab>
</Tabs>

### Verify the results

Finally, let's check the balances to confirm the transfer worked:

<Tabs items={["TypeScript", "Python"]}>
<Tabs.Tab>

Add this code after waiting for the transaction:

```ts filename="transaction.ts"
// Check final balances
const aliceFinalBalance = await aptos.getAccountAPTAmount({
  accountAddress: alice.accountAddress,
});
const bobFinalBalance = await aptos.getAccountAPTAmount({
  accountAddress: bob.accountAddress,
});

console.log("\n=== Final Balances ===");
console.log(`Alice: ${aliceFinalBalance} octas (spent ${aliceBalance - aliceFinalBalance} octas on transfer and gas)`);
console.log(`Bob: ${bobFinalBalance} octas (received 1000 octas)`);
```

</Tabs.Tab>
<Tabs.Tab>

Add this code after waiting for the transaction:

```python filename="transaction.py"
# Check final balances
alice_final_balance = await rest_client.account_balance(alice.address())
bob_final_balance = await rest_client.account_balance(bob.address())

print("\n=== Final Balances ===")
print(f"Alice: {alice_final_balance} octas (spent {alice_balance - alice_final_balance} octas on transfer and gas)")
print(f"Bob: {bob_final_balance} octas (received 1000 octas)")
```

</Tabs.Tab>
</Tabs>

### Run the complete code

Now run the complete program:

<Tabs items={["TypeScript", "Python"]}>
<Tabs.Tab>

```bash filename="Terminal"
npx ts-node transaction.ts
```

You should see output similar to:

```
Connected to Aptos devnet
=== Addresses ===
Alice's address: 0x978c213990c4833df71548df7ce49d54c759d6b6d932de22b24d56060b7af2aa
Bob's address: 0x7af2d6c93a2feafc9b69b5e8ad9d6b513b260f62f23f3a384a3a2e4a84694a9b

=== Funding accounts ===
Accounts funded successfully

=== Initial Balances ===
Alice: 100000000 octas
Bob: 0 octas

=== 1. Building the transaction ===
Transaction built successfully

=== 2. Simulating the transaction ===
Estimated gas units: 146
Estimated gas cost: 14600 octas

=== 3. Signing the transaction ===
Transaction signed successfully

=== 4. Submitting the transaction ===
Transaction submitted with hash: 0x3a8a3e34a1c64ad9d7636a3a827b7ec3bb12d73825b36fa06d425c5a3b42cccc

=== 5. Waiting for transaction completion ===
Transaction completed with status: SUCCESS

=== Final Balances ===
Alice: 99984400 octas (spent 15600 octas on transfer and gas)
Bob: 1000 octas (received 1000 octas)
```

</Tabs.Tab>
<Tabs.Tab>

```bash filename="Terminal"
python transaction.py
```

You should see output similar to:

```
Connected to Aptos devnet
=== Addresses ===
Alice's address: 0x978c213990c4833df71548df7ce49d54c759d6b6d932de22b24d56060b7af2aa
Bob's address: 0x7af2d6c93a2feafc9b69b5e8ad9d6b513b260f62f23f3a384a3a2e4a84694a9b

=== Funding accounts ===
Accounts funded successfully

=== Initial Balances ===
Alice: 100000000 octas
Bob: 0 octas

=== 1. Building the transaction ===
Transaction built successfully

=== 2. Simulating the transaction ===
Estimated gas units: 146
Estimated gas cost: 14600 octas

=== 3. Signing the transaction ===
Transaction signed successfully

=== 4. Submitting the transaction ===
Transaction submitted with hash: 0x3a8a3e34a1c64ad9d7636a3a827b7ec3bb12d73825b36fa06d425c5a3b42cccc

=== 5. Waiting for transaction completion ===
Transaction completed successfully

=== Final Balances ===
Alice: 99984400 octas (spent 15600 octas on transfer and gas)
Bob: 1000 octas (received 1000 octas)
```

</Tabs.Tab>
</Tabs>

<Callout type="info">
Notice that Alice's balance decreased by more than 1000 octas. The extra amount is the gas fee paid to process the transaction.
</Callout>
</Steps>

## 7. Understanding the Transaction Lifecycle

Let's review the five key steps in the transaction lifecycle:

1. **Build**: Create a transaction specifying the sender, function to call, and arguments
2. **Simulate** (Optional): Estimate the gas cost before committing
3. **Sign**: Authorize the transaction with the sender's private key
4. **Submit**: Send the signed transaction to the blockchain
5. **Wait**: Monitor the transaction until it's processed

This pattern is consistent across all transactions on Aptos, whether you're transferring coins, minting NFTs, or interacting with smart contracts.

## 8. Next Steps

Congratulations! You've successfully created and executed your first transaction on the Aptos blockchain. Here are some suggestions for what to explore next:

1. **Learn about more complex transactions**:
   - [Multi-Agent Signatures](building-transactions/multi-agent-transactions.mdx) - Transactions requiring multiple signers
   - [Sponsoring Transactions](building-transactions/sponsoring-transactions.mdx) - Having another account pay gas fees
   - [Batching Transactions](building-transactions/batching-transactions.mdx) - Sending multiple transactions efficiently

2. **Explore smart contracts**:
   - [Your First Move Module](first-move-module.mdx) - Create your own smart contract
   - [Your First Coin](first-coin.mdx) - Create a custom token

3. **Dive deeper into Aptos**:
   - [Account Basics](../../network/blockchain/accounts.mdx) - Learn more about accounts
   - [Gas and Transaction Fees](../../network/blockchain/gas.mdx) - Understand how gas works
   - [Join the Aptos Discord](https://discord.gg/aptoslabs) - Connect with the community

<Callout type="info">
How long did it take you to complete this tutorial? We'd love to hear your feedback to improve our documentation!
</Callout>

## Supporting Documentation

- [TypeScript SDK](../sdks/ts-sdk.mdx)
- [Python SDK](../sdks/python-sdk.mdx)
- [REST API Specification](../../network/nodes/aptos-api-spec.mdx)
