---
title: "Your First Transaction"
---

import { Callout, Steps, Tabs } from 'nextra/components'

# Your First Transaction

Transactions allow you to change on-chain data or trigger events by calling smart contract functions (called `entry functions`). Generally, transactions follow 5 steps from building to executing on chain: building, simulating, signing, submitting, and waiting.

<Callout type="info">
You can jump below to the full code sample or continue reading for a step-by-step walkthrough.
</Callout>

<Tabs items={["TypeScript", "Python"]}>

<Tabs.Tab>

<Steps>

### Build

Building a transaction is how you specify:

1. **The `sender` account.** This account normally pays the gas fees for this transaction.
2. **The `function` being called on-chain.** This is the identifier for the smart contract entry function on-chain that will trigger when you execute this transaction.
3. **The `functionArguments`.** This is any data the function needs to run.

This can be packaged into a `SimpleTransaction` using `aptos.transaction.build.simple(...)` like so:

```ts filename="build-a-transaction.ts"
const transaction = await aptos.transaction.build.simple({
  sender: sender.accountAddress,
  data: {
    // All transactions on Aptos are implemented via smart contracts.
    function: "0x1::aptos_account::transfer",
    functionArguments: [destination.accountAddress, 100],
  },
});
```

<Callout type="info">
There is a more advanced format to pass in `functionArguments` called [Binary Canonical Serialization (BCS)](building-transactions/bcs-format.mdx) which is how the Aptos chain parses function arguments. The SDK converts TypeScript primitives to BCS format behind the scenes via an API call.
</Callout>

### Simulate (Optional)

Every transaction on the Aptos chain has a gas fee associated with how much work the network machines have to do when executing the transaction. In order to estimate the cost associated with that, you can simulate transactions before committing them.

<Callout type="info">
This simulation only requires the `publicKey` of an account since it will not impact the actual state of the ledger.
</Callout>

```ts filename="build-a-transaction.ts"
const [userTransactionResponse] = await aptos.transaction.simulate.simple({
  signerPublicKey: signer.publicKey,
  transaction,
});
// If the fee looks ok, continue to signing!
```

### Sign

Once the transaction is built and the fees seem reasonable, you can sign the transaction with `aptos.transaction.sign`. The signature must come from the `sender` account.

```ts filename="build-a-transaction.ts"
// 3. Sign
const senderAuthenticator = aptos.transaction.sign({
  signer: sender,
  transaction,
});
```

### Submit

Now that the transaction is signed, you can submit it to the network using `aptos.transaction.submit.simple` like so:

```ts filename="build-a-transaction.ts"
// 4. Submit
const committedTransaction = await aptos.transaction.submit.simple({
  transaction,
  senderAuthenticator,
});
```

### Wait

Finally, you can wait for the result of the transaction by using `aptos.waitForTransaction` and specifying the hash of the transaction you just submitted like so:

```ts filename="build-a-transaction.ts"
// 5. Wait
const executedTransaction = await aptos.waitForTransaction({ transactionHash: committedTransaction.hash });
```

</Steps>

## Full TypeScript Example

```ts filename="build-a-transaction.ts"
/**
 * This example shows how to use the Aptos SDK to send a transaction.
 * Don't forget to install @aptos-labs/ts-sdk before running this example!
 */

import {
  Account,
  Aptos,
  AptosConfig,
  Network,
} from "@aptos-labs/ts-sdk";

async function example() {
  console.log("This example will create two accounts (Alice and Bob) and send a transaction transferring APT to Bob's account.");

  // 0. Setup the client and test accounts
  const config = new AptosConfig({ network: Network.DEVNET });
  const aptos = new Aptos(config);

  let alice = Account.generate();
  let bob = Account.generate();

  console.log("=== Addresses ===\n");
  console.log(`Alice's address is: ${alice.accountAddress}`);
  console.log(`Bob's address is: ${bob.accountAddress}`);

  console.log("\n=== Funding accounts ===\n");
  await aptos.fundAccount({
    accountAddress: alice.accountAddress,
    amount: 100_000_000,
  });
  await aptos.fundAccount({
    accountAddress: bob.accountAddress,
    amount: 100,
  });
  console.log("Funded Alice and Bob's accounts!");

  // 1. Build
  console.log("\n=== 1. Building the transaction ===\n");
  const transaction = await aptos.transaction.build.simple({
    sender: alice.accountAddress,
    data: {
      // All transactions on Aptos are implemented via smart contracts.
      function: "0x1::aptos_account::transfer",
      functionArguments: [bob.accountAddress, 100],
    },
  });
  console.log("Built the transaction!");

  // 2. Simulate (Optional)
  console.log("\n=== 2. Simulating Transaction (Optional) ===\n");
  const [userTransactionResponse] = await aptos.transaction.simulate.simple({
    signerPublicKey: alice.publicKey,
    transaction,
  });
  console.log(userTransactionResponse);

  // 3. Sign
  console.log("\n=== 3. Signing transaction ===\n");
  const senderAuthenticator = aptos.transaction.sign({
    signer: alice,
    transaction,
  });
  console.log("Signed the transaction!");

  // 4. Submit
  console.log("\n=== 4. Submitting transaction ===\n");
  const submittedTransaction = await aptos.transaction.submit.simple({
    transaction,
    senderAuthenticator,
  });
  console.log(`Submitted transaction hash: ${submittedTransaction.hash}`);

  // 5. Wait
  console.log("\n=== 5. Waiting for result of transaction ===\n");
  const executedTransaction = await aptos.waitForTransaction({
    transactionHash: submittedTransaction.hash,
  });
  console.log(executedTransaction);
}

example();
```

</Tabs.Tab>

<Tabs.Tab>

<Steps>

### Build

Building a transaction is how you specify:

1. **The `sender` account.** This account normally pays the gas fees for this transaction.
2. **The `function` being called on-chain.** This is the identifier for the smart contract entry function on-chain that will trigger when you execute this transaction.
3. **The `functionArguments`.** This is any data the function needs to run.

This can be packaged into an `EntryFunction.natural` like so:

```python filename="build-a-transaction.py"
# You can modify this payload to call whichever smart contract entry function you want. 
# module - "0x1::aptos_account" indicates the address and module. 
# function - "transfer" is the name of the function we are calling.
# ty_args - Transfer has no type parameters, so we leave that blank with [].
# args - Then we add the arguments to the "transfer" function. We wrap them in "TransactionArgument" to get them
#        into the proper Binary Canonical Serialization (BCS) format so the chain can understand the data.
#
# See the Move Reference to find the function signatures for entry functions: https://aptos.dev/en/build/smart-contracts/reference 
payload = EntryFunction.natural(
    "0x1::aptos_account",
    "transfer",
    [],
    [
        TransactionArgument(recipient, Serializer.struct),
        TransactionArgument(amount, Serializer.u64),
    ],
)
```

### Simulate (Optional)

Every transaction on the Aptos chain has a gas fee associated with how much work the network machines have to do when executing the transaction. In order to estimate the cost associated with that, you can simulate transactions before committing them.

```python filename="build-a-transaction.py"
try:
    raw_transaction = await rest_client.create_bcs_transaction(sender, TransactionPayload(payload))
    simulation_result = await rest_client.simulate_transaction(raw_transaction, sender)
    print("Simulation successful. Transaction output:")
    print(simulation_result)
except Exception as e:
    print("Simulation failed:", str(e))
# If the fee looks ok, continue to signing!
```

### Sign

Once the transaction is built and the fees seem reasonable, you can sign the transaction with `rest_client.create_bcs_signed_transaction`. The signature must come from the `sender` account.

```python filename="build-a-transaction.py"
signed_transaction = await rest_client.create_bcs_signed_transaction(
    sender, TransactionPayload(payload), sequence_number=sequence_number
)
```

### Submit

Now that the transaction is signed, you can submit it to the network using `rest_client.submit_bcs_transaction` like so:

```python filename="build-a-transaction.py"
txn_hash = await rest_client.submit_bcs_transaction(signed_transaction)
```

### Wait

Finally, you can wait for the result of the transaction by using `rest_client.wait_for_transaction` and specifying the hash of the transaction you just submitted:

```python filename="build-a-transaction.py"
if txn_hash:
    await rest_client.wait_for_transaction(txn_hash)
```

</Steps>

## Full Python Example

<Callout type="info">
You can import the Python SDK by running `pip3 install aptos-sdk`.
</Callout>

```python filename="build-a-transaction.py"
"""
This example shows how to use the Aptos client to create accounts, fund them, simulate a transaction, and transfer between accounts.
"""

import asyncio

from aptos_sdk.account import Account
from aptos_sdk.async_client import FaucetClient, RestClient
from aptos_sdk.bcs import Serializer
from aptos_sdk.transactions import (
    EntryFunction,
    TransactionArgument,
    TransactionPayload,
)

# Constants for the Aptos network URLs
NODE_URL = "https://fullnode.devnet.aptoslabs.com/v1"
FAUCET_URL = "https://faucet.devnet.aptoslabs.com"
FAUCET_AUTH_TOKEN = None  # Set this if using an authenticated faucet

# Constants for the coin and initial balances
ALICE_INITIAL_BALANCE = 100_000_000
TRANSFER_AMOUNT = 1_000

# A helper that handles the 5 steps to build and execute a transaction. Modify this to change which entry function you want to call.
async def build_and_submit_transfer_transaction(
    rest_client: RestClient, sender: Account, recipient: Account, amount: int, sequence_number: int = None, simulate: bool = False
):
    # 1. Build the transaction payload. 

    # You can modify this payload to call whichever smart contract entry function you want. 
    # module - "0x1::aptos_account" indicates the address and module. 
    # function - "transfer" is the name of the function we are calling.
    # ty_args - Transfer has no type parameters, so we leave that blank with [].
    # args - Then we add the arguments to the "transfer" function. We wrap them in "TransactionArgument" to get them
    #        into the proper Binary Canonical Serialization (BCS) format so the chain can understand the data.
    # 
    # See the Move Reference to find the function signatures for entry functions: https://aptos.dev/en/build/smart-contracts/reference 
    print("\n=== Building the transaction payload ===")
    payload = EntryFunction.natural(
        "0x1::aptos_account",
        "transfer",
        [],
        [
            TransactionArgument(recipient, Serializer.struct),
            TransactionArgument(amount, Serializer.u64),
        ],
    )

    # 2. (Optional) Simulate the transaction if requested
    if simulate:
        print("\n=== Simulating Transaction ===")
        print("You can use this to check gas fees before committing to executing the transaction.")
        try:
            raw_transaction = await rest_client.create_bcs_transaction(sender, TransactionPayload(payload))
            simulation_result = await rest_client.simulate_transaction(raw_transaction, sender)
            print("Simulation successful. Transaction output:")
            print(simulation_result)
        except Exception as e:
            print("Simulation failed:", str(e))
            return None

    # 3. Sign the transaction
    print("\n=== Signing the transaction ===")
    signed_transaction = await rest_client.create_bcs_signed_transaction(
        sender, TransactionPayload(payload), sequence_number=sequence_number
    )

    # 4. Submit the transaction onchain
    print("\n=== Submitting the transaction ===")
    txn_hash = await rest_client.submit_bcs_transaction(signed_transaction)

    # 5. Wait for the transaction to complete
    if txn_hash:
        print("\n=== Waiting for the transaction to complete ===")
        await rest_client.wait_for_transaction(txn_hash)
        print("\n=== Transaction has been completed ===")

    return txn_hash

# This main function demonstrates how to transfer coins between multiple accounts using transactions.
async def main():
    # Setup the clients
    rest_client = RestClient(NODE_URL)
    faucet_client = FaucetClient(FAUCET_URL, rest_client, FAUCET_AUTH_TOKEN)

    # Generate two accounts
    alice = Account.generate()
    bob = Account.generate()

    print("\n=== Addresses ===")
    print(f"Alice's address: {alice.address()}")
    print(f"Bob's address: {bob.address()}")

    # Fund the accounts using the faucet
    alice_fund = faucet_client.fund_account(alice.address(), ALICE_INITIAL_BALANCE)
    bob_fund = faucet_client.fund_account(bob.address(), 0)
    await asyncio.gather(alice_fund, bob_fund)

    print("\n=== Initial Balances ===")
    alice_balance_task = rest_client.account_balance(alice.address())
    bob_balance_task = rest_client.account_balance(bob.address())
    alice_balance, bob_balance = await asyncio.gather(alice_balance_task, bob_balance_task)
    print(f"Alice's balance: {alice_balance}")
    print(f"Bob's balance: {bob_balance}")

    # Perform a transfer from Alice to Bob with simulation
    print("\n=== Performing Transfer with Simulation ===")
    txn_hash = await build_and_submit_transfer_transaction(
        rest_client, alice, bob.address(), TRANSFER_AMOUNT, simulate=True
    )

    print("\n=== Final Balances ===")
    alice_balance_task = rest_client.account_balance(alice.address())
    bob_balance_task = rest_client.account_balance(bob.address())
    alice_balance, bob_balance = await asyncio.gather(alice_balance_task, bob_balance_task)
    print(f"Alice's balance: {alice_balance}")
    print(f"Bob's balance: {bob_balance}")

    await rest_client.close()

if __name__ == "__main__":
    asyncio.run(main())
```

</Tabs.Tab>

</Tabs>

## Summary

Building and sending transactions on-chain involves the following 5 steps:
1. **Build** the transaction.
2. **Simulate** the cost. (Optional)
3. **Sign** the transaction (if the simulated cost seems ok).
4. **Submit** the transaction to the network.
5. **Wait** for the chain to validate and update.

## Explore Advanced Transaction Features

<Callout type="warning">
These guides below are written for TypeScript, but the Python SDK does have similar features implemented. See the [Python SDK GitHub](https://github.com/aptos-labs/aptos-python-sdk/tree/main/examples) for example code which demonstrates these features.
</Callout>

1. [Multi-Agent Signatures](building-transactions/multi-agent-transactions.mdx) - Allowing multiple accounts to be used for a single contract.
2. [Sponsoring Transactions](building-transactions/sponsoring-transactions.mdx) - Have another account pay gas fees for this transaction.
3. [Batch Submit Transactions](building-transactions/batching-transactions.mdx) - How to send multiple transactions quickly from a single account.
4. [Binary Canonical Serialization (BCS)](building-transactions/bcs-format.mdx) - The format used to serialize data for Aptos transactions.
5. [Composing multiple Move calls with ScriptComposer](building-transactions/script-composer.mdx) - (Experimental) Building more complex transaction payload that calls into multiple Move functions dynamically.
