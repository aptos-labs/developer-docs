import {Callout} from "nextra/components";

# パッケージのアップグレード

Aptosブロックチェーン上のMoveコード（例：Moveモジュール）はアップグレード可能です。これにより、コードの所有者やモジュール開発者は、単一の安定した既知のアカウントアドレスの下でコントラクトを更新・進化させることができます。モジュールがアップグレードされた場合、そのモジュールのすべての利用者は自動的に最新バージョンのコードを受け取ります（例：次回の対話時）。

Aptosブロックチェーンは、異なる_アップグレードポリシー_をネイティブにサポートしており、Move開発者がコードのアップグレード方法に関する制約を明示的に定義できます。デフォルトのポリシーは_後方互換性_です。これは、既存のリソースストレージやパブリックAPI（パブリック関数を含む）がアップグレードによって破壊されないことが保証される場合にのみ、コードのアップグレードが受け入れられることを意味します。この互換性チェックは、Moveの強力な型付けバイトコードセマンティクスによって可能となっています。

ただし、互換性のあるアップグレードであっても、アプリケーションや依存するMoveコードに危険な影響を与える可能性があることに注意してください（例えば、基礎となるモジュールのセマンティクスが変更された場合など）。そのため、開発者は、オンチェーンでアップグレード可能なサードパーティのMoveコードに依存する際は注意が必要です。詳細については、[依存関係のセキュリティ考慮事項](#security-considerations-for-dependencies)を参照してください。

## 仕組み

AptosブロックチェーンでのMoveコードのアップグレードは、[Moveパッケージ](packages.mdx)単位で行われます。パッケージは`Move.toml`マニフェストでアップグレードポリシーを指定します：

```toml
[package]
name = "MyApp"
version = "0.0.1"
upgrade_policy = "compatible"
...
```

<Callout type="info">
Aptosは、Moveパッケージがトランザクションを通じて公開される時点で互換性をチェックします。互換性がないと判断された場合、このトランザクションは中止されます。
</Callout>

## アップグレード方法

既に公開されているMoveコードをアップグレードするには、以前に公開されたのと同じアドレスでコードを再公開するだけです。これは、[Aptos CLI](../../cli/working-with-move-contracts.mdx)を使用したコードのコンパイルと公開の手順に従うことで実行できます。例については、[初めてのMoveモジュール](../../guides/first-move-module.mdx)チュートリアルを参照してください。

## アップグレードポリシー

Aptosは現在、2つの異なるアップグレードポリシーをサポートしています：

- `compatible`：これらのアップグレードは後方互換性がなければなりません：
  - ストレージについては、古い構造体の宣言はすべて新しいコードでも同じでなければなりません。これにより、既存のストレージの状態が新しいコードによって正しく解釈されることが保証されます。ただし、新しい構造体の宣言は追加できます。
  - APIについては、既存のすべてのパブリック関数は以前と同じシグネチャを持つ必要があります。新しい関数（パブリック関数やエントリー関数を含む）は追加できます。
- `immutable`：コードはアップグレード不可で、永久に同じ状態が保証されます。

これらのポリシーは、強さに関して`compatible < immutable`の順序付けがされています（つまり、compatibleはimmutableより弱い）。オンチェーン上のパッケージのポリシーは、より強くなることはあっても弱くなることはありません。さらに、パッケージのすべての依存関係は、そのパッケージのポリシーと同等かそれ以上の強さを持つ必要があります。例えば、`immutable`パッケージは`compatible`パッケージを直接的または間接的に参照することはできません。これにより、予期せぬアップデートが裏で発生しないことが保証されます。

ただし、上記のルールには1つの例外があります：アドレス`0x1`から`0xa`にインストールされているフレームワークパッケージは、依存関係チェックから除外されます。これは、重要なアップグレードと修正を可能にするため`compatible`ポリシーを持つ標準ライブラリに基づいて`immutable`パッケージを定義できるようにするために必要です。

## 互換性ルール

`compatible`アップグレードポリシーを使用する場合、モジュールパッケージはアップグレード可能です。ただし、以前に公開された既存のモジュールへの更新は互換性があり、以下のルールに従う必要があります：

- 既存の構造体のフィールドは更新できません。これは、新しいフィールドを追加することも、既存のフィールドを変更することもできないことを意味します。
- すべてのパブリック関数とエントリー関数は、シグネチャ（引数の型、型引数、戻り値の型）を変更できません。ただし、引数名は変更できます。
- `public(friend)`関数はプライベートとして扱われるため、シグネチャは任意に変更できます。これは、同じパッケージ内のモジュールのみがフレンド関数を呼び出すことができ、シグネチャが変更された場合は更新する必要があるため、安全です。
- [列挙型のアップグレード互換性ルール](enums.mdx#enum-type-upgrade-compatibility)。
- 構造体/列挙型の既存の機能は削除できません（ただし、機能は追加できます）。

モジュールを更新する際に互換性エラーが表示された場合は、上記のルールを確認し、違反を修正してください。

## 依存関係のセキュリティ考慮事項

前述のように、互換性のあるアップグレードであっても、依存するアプリケーションに壊滅的な影響を与える可能性があります。これらの影響はバグによって生じる可能性がありますが、悪意のあるアップグレードの結果である可能性もあります。例えば、アップグレードされた依存関係が突然すべての関数を中止させ、あなたのMoveコードの動作を破壊する可能性があります。あるいは、アップグレードされた依存関係が突然、すべての関数の実行に以前よりもはるかに多くのガスを必要とするようになる可能性があります。そのため、アップグレード可能なパッケージへの依存関係は慎重に扱う必要があります：

- もちろん、最も安全な依存関係は`immutable`パッケージです。これは、依存関係が決して変更されないことを保証します（推移的な依存関係を含む）。immutableパッケージを更新するためには、所有者は新しいメジャーバージョンを導入する必要があります。これは実質的に、新しい別個の独立したパッケージをデプロイするようなものです。これは、メジャーバージョニングは名前でのみ表現できるためです（例：`module feature_v1`と`module feature_v2`）。ただし、すべてのパッケージ所有者が自分のコードを`immutable`として公開することを好むわけではありません。なぜなら、これによってバグを修正し、コードをその場で更新する能力が失われるためです。
- `compatible`パッケージへの依存関係がある場合は、パッケージを公開するエンティティを知り、理解することを強く推奨します。最高レベルの保証は、パッケージが分散型自律組織（DAO）によって管理されている場合です。この場合、単一のユーザーがアップグレードを開始することはできず、投票などが必要です。これはAptosフレームワークの場合に当てはまります。

## プログラムによるアップグレード

一般的に、AptosはMoveモジュール`aptos_framework::code`を通じて、スマートコントラクトのどこからでもコードを公開する方法を提供しています。ただし、現在のトランザクションで公開されたコードは、そのトランザクションが終了した後でのみ実行できることに注意してください。

Aptosフレームワーク自体（オンチェーンの管理ロジックを含む）は、プログラムによるアップグレードの例です。フレームワークは`compatible`としてマークされています。アップグレードは特定の生成されたガバナンススクリプトを通じて行われます。詳細については、[Aptosガバナンス](../../../network/blockchain/governance.mdx)を参照してください。
