# タプルとユニット

Moveは、[第一級の値](https://en.wikipedia.org/wiki/First-class_citizen)として他の言語で期待されるようなタプルを完全にはサポートしていません。ただし、複数の戻り値をサポートするために、Moveにはタプルのような式があります。これらの式は実行時に具体的な値を生成せず（バイトコードにタプルは存在しません）、その結果、非常に制限されています：式（通常は関数の戻り値の位置）でのみ使用でき、ローカル変数にバインドできず、構造体に格納できず、タプル型をジェネリクスのインスタンス化に使用することもできません。

同様に、[ユニット`()`](https://en.wikipedia.org/wiki/Unit_type)は、式ベースにするためにMove言語によって作成された型です。ユニット値`()`は実行時の値を生成しません。ユニット`()`は空のタプルと考えることができ、タプルに適用される制限はすべてユニットにも適用されます。

これらの制限を考えると、言語にタプルが存在すること自体が奇妙に感じるかもしれません。しかし、他の言語でのタプルの最も一般的な使用例の1つは、関数が複数の値を返すことを可能にすることです。一部の言語では、複数の戻り値を含む構造体を書くことを強制することでこれを回避しています。しかし、Moveでは[構造体](structs-and-resources.mdx)の中に参照を入れることができません。これにより、Moveは複数の戻り値をサポートする必要がありました。これらの複数の戻り値はバイトコードレベルですべてスタックにプッシュされます。ソースレベルでは、これらの複数の戻り値はタプルを使用して表現されます。

## リテラル

タプルは、括弧内のカンマで区切られた式のリストによって作成されます。

| 構文           | 型                                                                          | 説明                                                     |
| ------------- | ---------------------------------------------------------------------------- | -------------------------------------------------------- |
| `()`          | `(): ()`                                                                     | ユニット、空のタプル、または要素数0のタプル               |
| `(e1, ..., en)` | `(e1, ..., en): (T1, ..., Tn)` ここで `e_i: Ti` かつ `0 < i <= n` かつ `n > 0` | `n`個の要素を持つタプル |

注意：`(e)`は`(e): (t)`型を持ちません。つまり、1つの要素を持つタプルは存在しません。括弧内に単一の要素がある場合、括弧は曖昧さを解消するためだけに使用され、他の特別な意味は持ちません。

2つの要素を持つタプルは「ペア」、3つの要素を持つタプルは「トリプル」と呼ばれることがあります。

### 例

```move
module 0x42::example {
  // 以下の3つの関数は同等です

  // 戻り値の型が指定されていない場合、`()`と見なされます
  fun returns_unit_1() { }

  // 空の式ブロックには暗黙的な()値があります
  fun returns_unit_2(): () { }

  // `returns_unit_1`と`returns_unit_2`の明示的なバージョン
  fun returns_unit_3(): () { () }


  fun returns_3_values(): (u64, bool, address) {
    (0, false, @0x42)
  }
  fun returns_4_values(x: &u64): (&u64, u8, u128, vector<u8>) {
    (x, 0, 1, b"foobar")
  }
}
```

## 操作

現在、タプルで実行できる唯一の操作は分解です。

### 分解

任意のサイズのタプルは、`let`バインディングまたは代入で分解できます。

例：

```move
module 0x42::example {
  // 以下の3つの関数は同等です
  fun returns_unit() {}
  fun returns_2_values(): (bool, bool) { (true, false) }
  fun returns_4_values(x: &u64): (&u64, u8, u128, vector<u8>) { (x, 0, 1, b"foobar") }

  fun examples(cond: bool) {
    let () = ();
    let (x, y): (u8, u64) = (0, 1);
    let (a, b, c, d) = (@0x0, 0, false, b"");

    () = ();
    (x, y) = if (cond) (1, 2) else (3, 4);
    (a, b, c, d) = (@0x1, 1, true, b"1");
  }

  fun examples_with_function_calls() {
    let () = returns_unit();
    let (x, y): (bool, bool) = returns_2_values();
    let (a, b, c, d) = returns_4_values(&0);

    () = returns_unit();
    (x, y) = returns_2_values();
    (a, b, c, d) = returns_4_values(&1);
  }
}
```

詳細については、[Move変数](variables.mdx)を参照してください。

## サブタイピング

参照とともに、タプルはMoveで[サブタイピング](https://en.wikipedia.org/wiki/Subtyping)を持つ唯一の他の型です。タプルは、参照と共変的な方法でサブタイプ化する意味でのみサブタイピングを持ちます。

例：

```move
script {
  fun example() {
    let x: &u64 = &0;
    let y: &mut u64 = &mut 1;

    // (&u64, &mut u64)は(&u64, &u64)のサブタイプです
    // なぜなら&mut u64は&u64のサブタイプだからです
    let (a, b): (&u64, &u64) = (x, y);

    // (&mut u64, &mut u64)は(&u64, &u64)のサブタイプです
    // なぜなら&mut u64は&u64のサブタイプだからです
    let (c, d): (&u64, &u64) = (y, y);

    // エラー！(&u64, &mut u64)は(&mut u64, &mut u64)のサブタイプではありません
    // なぜなら&u64は&mut u64のサブタイプではないからです
    let (e, f): (&mut u64, &mut u64) = (x, y);
  }
}
```

## 所有権

上述のように、タプル値は実行時に実際には存在しません。そのため、現在はローカル変数に格納することができません（ただし、この機能は近い将来追加される可能性があります）。そのため、現在タプルは移動のみが可能で、コピーするにはローカル変数に格納する必要があります。
