# アドレス

`address`は、グローバルストレージ内の場所（アカウントとも呼ばれる）を表すMoveの組み込み型です。`address`値は256ビット（32バイト）の識別子です。アドレスには、[モジュール](modules-and-scripts.mdx)と[リソース](structs-and-resources.mdx)の2種類のデータを格納できます。

内部的には`address`は256ビット整数ですが、Moveのアドレスは意図的に不透明です - 整数から作成することはできず、算術演算をサポートせず、変更することもできません。C言語のポインタ演算のような興味深いプログラムを書くことができるかもしれませんが、Moveは静的検証をサポートするために設計されているため、このような動的な動作は許可されていません。

実行時のアドレス値（`address`型の値）を使用して、そのアドレスのリソースにアクセスできます。実行時にアドレス値を使用してモジュールにアクセスすることは_できません_。

## アドレスとその構文

アドレスには、名前付きアドレスと数値アドレスの2種類があります。名前付きアドレスの構文は、Moveの他の識別子と同じ規則に従います。数値アドレスの構文は16進数に限定されず、[`u256`の有効な数値](integers.mdx)であれば任意の値を使用できます。例えば、`42`、`0xCAFE`、`2021`はすべて有効な数値アドレスリテラルです。

アドレスが式のコンテキストで使用されているかどうかを区別するために、アドレスの使用構文はコンテキストによって異なります：

- アドレスが式として使用される場合、アドレスの前に`@`文字を付ける必要があります。つまり、[`@<数値>`](integers.mdx)または`@<名前付きアドレス識別子>`となります。
- 式のコンテキスト以外では、アドレスは先頭の`@`文字なしで記述できます。つまり、[`<数値>`](integers.mdx)または`<名前付きアドレス識別子>`となります。

一般的に、`@`は名前空間項目を式項目に変換する演算子と考えることができます。

## 名前付きアドレス

名前付きアドレスは、アドレスが使用される場所で数値の代わりに識別子を使用できる機能です。これは値レベルだけでなく、アドレスが使用されるすべての場所で使用できます。名前付きアドレスは、Moveパッケージのトップレベル要素（モジュールとスクリプトの外部）として宣言およびバインドされるか、Moveコンパイラに引数として渡されます。

名前付きアドレスはソース言語レベルでのみ存在し、バイトコードレベルでは完全に値に置き換えられます。このため、モジュールとモジュールメンバーは、コンパイル時に名前付きアドレスに割り当てられた数値を通じてではなく、モジュールの名前付きアドレスを通じてアクセスする_必要があります_。例えば、`my_addr::foo`は`0x2::foo`と_同等ではありません_。これは、Moveプログラムが`my_addr`を`0x2`に設定してコンパイルされた場合でも同様です。この区別については、[モジュールとスクリプト](modules-and-scripts.mdx)のセクションで詳しく説明します。

### 例

```move
script {
  fun example() {
    let a1: address = @0x1; // 0x0000000000000000000000000000000000000000000000000000000000000001の省略形
    let a2: address = @0x42; // 0x0000000000000000000000000000000000000000000000000000000000000042の省略形
    let a3: address = @0xDEADBEEF; // 0x00000000000000000000000000000000000000000000000000000000DEADBEEFの省略形
    let a4: address = @0x000000000000000000000000000000000000000000000000000000000000000A;
    let a5: address = @std; // 名前付きアドレス`std`の値を`a5`に代入
    let a6: address = @66;
    let a7: address = @0x42;
  }
}

module 66::some_module {   // 式のコンテキストではないため、@は不要
    use 0x1::other_module; // 式のコンテキストではないため、@は不要
    use std::vector;       // 他のモジュールを使用する際の名前空間項目として名前付きアドレスを使用可能
    ...
}

module std::other_module {  // モジュールを宣言する際の名前空間項目として名前付きアドレスを使用可能
    ...
}
```

## グローバルストレージ操作

`address`値の主な目的は、グローバルストレージ操作とのやり取りです。

`address`値は、`exists`、`borrow_global`、`borrow_global_mut`、`move_from`の[操作](global-storage-operators.mdx)で使用されます。

`address`を使用しないグローバルストレージ操作は`move_to`のみで、これは[`signer`](signer.mdx)を使用します。

## 所有権

言語に組み込まれている他のスカラー値と同様に、`address`値は暗黙的にコピー可能です。つまり、[`copy`](variables.mdx#move-and-copy)のような明示的な命令なしでコピーできます。
