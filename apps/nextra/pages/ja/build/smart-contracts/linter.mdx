---
title: "Aptos Move リンター"
---

# Aptos Move リンター

「Aptos Move リンター」ツールは、Move プログラムの一般的な問題を見つけて警告し、Move コードの品質向上を支援するツールです。

aptos CLI コマンドで実行できます：`aptos move lint`

このツールは現在ベータ版です。ぜひ試していただき、[バグや感想](https://github.com/aptos-labs/aptos-core/issues/new?title=%5Blinter%5D%20%3CDescriptive%20Title%3E&body=%3CDetailed%20description%20of%20the%20issue%20or%20feature%20request%3E&labels=move-linter&projects=aptos-labs/16)をお寄せください。また、新しいリントルールのアイデアと優先順位付けの要望は[こちら](https://github.com/aptos-labs/aptos-core/issues/15221)で管理しています。皆様のご協力をお待ちしております。

## リントチェック
### `avoid_copy_on_identity_comparison`

`vector`や`struct`型（コピーが高コストになる可能性がある型）のコピーされた値間での同一性比較（`==`または`!=`）をチェックします。代わりに、参照ベースの同一性比較の使用を推奨します（上記の条件に該当する場合、`x == y`の代わりに`&x == &y`を使用）。

この推奨事項は[Move ブックでも言及](book/equality.mdx#avoid-extra-copies)されています。自動コピー推論により、`copy`能力を持つ型の値に対して`==`や`!=`を使用する際に、コピーが行われているかどうかが分かりにくい場合があります。このリントは、参照ベースの同一性比較を使用することで、ベクターや構造体の不要なコピーを回避できるケースを特定します。

### `blocks_in_conditions`

条件文（`if`、`match`、`while`の条件など）でのブロックの使用をチェックします。これはコードの可読性を低下させる可能性があります。このリントが検出するコーディングパターンの例：

```move
if ({let x = foo(); !x}) { // 条件文でブロックを使用
  bar();
}
```

このようなコードは通常、ブロックを条件文の前に移動することで、より読みやすく書き直すことができます。

Move では、特にループ不変式などのインライン仕様を条件文で提供することが一般的なパターンであり、これには条件文でのブロックの作成が必要です。このパターンは仕様記述のために必要なため、このリントチェックから除外されています。

なお、`assert!`は条件付きアボートに変換されるため、`assert!`の条件でのブロックもこのリントによって報告されます。

### `needless_bool`

以下のようなパターンをチェックします（`x`は任意のブール式）：

- `if (x) true else false` は単に `x` に置き換えられます。
- `if (x) false else true` は単に `!x` に置き換えられます。
- `if (x) { return true } else { return false }` は単に `return x` に置き換えられます。
- `if (x) { return false } else { return true }` は単に `return !x` に置き換えられます。
- `if (x) true else true` または `if (x) false else false` は、冗長な分岐を削除するように書き直す必要があります。

### `needless_deref_ref`

参照を取得して直ちに参照解除するパターンをチェックし、参照解除-参照演算子のペアを削除することを提案します：

- `*&x.f` は `x.f` に簡略化できます
- `*&mut x.f` は `x.f` に簡略化できます
- `*&mut x.f = 5;` は `x.f = 5;` に簡略化できます

### `needless_mutable_reference`

可変的に使用されていない可変参照や借用（現在：可変参照パラメータ、ローカル変数の可変借用、`borrow_global_mut`）をチェックし、代わりに不変参照や借用を使用することを提案します。

例えば、以下の関数`foo`では、参照が可変的に使用されていないため、`&mut`を`&`に置き換えることができます。

```move
fun foo(x: u64): u64 {
  let y = &mut x;
  *y
}
```

### `needless_ref_deref`

参照解除のために不変参照を取得するパターンをチェックし、参照-参照解除演算子のペアを削除することを提案します：`&*x`は`x`に簡略化できます。

### `needless_ref_in_field_access`

構造体や列挙型のフィールドにアクセスする際に不要な参照を取得するパターンをチェックし、明示的な参照取得を削除することを提案します：

- `(&s).f` は `s.f` に簡略化できます
- `(&mut s).f = 42;` は `s.f = 42;` に簡略化できます

### `simpler_numeric_expression`

より単純な数値式を使用できるさまざまなパターンをチェックします。これらのケースでは、コードは既に型チェックを通過している必要があり、`x`は任意の数値式です。

- `x & 0`、`x * 0`、`0 & x`、`0 * x`、`0 << x`、`0 >> x`、`x % 1` はすべて単に `0` に置き換えられます。
- `x | 0`、`x ^ 0`、`x >> 0`、`x << 0`、`x + 0`、`x - 0`、`x / 1`、`x * 1`、`0 | x`、`0 ^ x`、`0 + x`、`1 * x` はすべて単に `x` に置き換えられます。

### `unnecessary_boolean_identity_comparison`

以下の形式のブール値の同一性比較をチェックします：

- `x == true`、`true == x` は単に `x` に置き換えられます。
- `x == false`、`false == x` は単に `!x` に置き換えられます。

これらのケースでは、`x`は任意のブール式です。

### `unnecessary_numerical_extreme_comparison`

不要な、あるいはより正確で明確にできる、極値（その数値型で表現可能な最小値と最大値）との数値比較をチェックします。比較に応じて、さまざまな推奨事項が提示されます。

リントによって検出される例と、それに対応する推奨事項を以下に示します（これらのケースでは、`x`は`u8`、`u16`、`u32`、`u64`、`u128`、または`u256`型の数値式のプレースホルダーで、`MAX`はその数値型で表現可能な最大値のプレースホルダーです）：

- `x < 0`、`0 > x`、`x > MAX`、`MAX < x` は常に偽となるため、この比較を削除するようにコードを書き直してください
- `x >= 0`、`0 <= x`、`x <= MAX`、`MAX >= x` は常に真となるため、この比較を削除するようにコードを書き直してください
- `x <= 0`、`0 >= x`、`x >= MAX`、`MAX <= x` はすべて代わりに `==` を使用して簡略化できます
- `x > 0`、`0 < x`、`x < MAX`、`MAX > x` はすべて代わりに `!=` を使用してより明確にできます

### `while_true`

`while (true) { .... }` パターンをチェックし、より明示的な `loop { .... }` 構文の使用を提案します。

## リント警告の抑制

`check1`、`check2`、...（など）という名前の1つ以上のリントチェックを抑制するには、関数やモジュールに `#[lint::skip(check1, check2, ...)]` 属性を追加します。リンターは、その関数やモジュールに対して `check1`、`check2`、...（など）という名前のチェックを実行しません。

例えば、以下の関数は通常 `needless_bool` についてリンターから警告を受けますが、関数に付けられた属性により、リンターは警告を出しません。

```move
#[lint::skip(needless_bool)]
fun violation(): bool {
    if (foo()) true else false
}
```
