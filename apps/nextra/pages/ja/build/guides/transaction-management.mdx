# トランザクション管理

このガイドでは、Aptosブロックチェーン上でスケーラブルなトランザクション管理の仕組みを構築する方法について説明します。

## 背景

Aptosでは、トランザクションは、そのトランザクションに署名または承認し、アカウントベースのシーケンス番号を提供するエンティティとしてのアカウントに紐付けられます。Aptosネットワークが新しいトランザクションを受信すると、以下のルールに従って処理されます：

- アカウントから送信されたトランザクションは、そのアカウントによって正しく承認される必要があります。
- 最新の台帳更新によって定義された現在時刻は、トランザクションの有効期限タイムスタンプより前である必要があります。
- トランザクションのシーケンス番号は、そのアカウントのチェーン上のシーケンス番号以上である必要があります。

初期ノードがトランザクションを受け入れた後、トランザクションは追加のルールに従ってシステム内を進みます。トランザクションのシーケンス番号が現在のチェーン上のシーケンス番号より高い場合、パス上のすべてのノードがチェーン上の状態と現在のシーケンス番号の間のシーケンス番号を持つトランザクションを確認している場合にのみ、コンセンサスに向けて進むことができます。

例：

Aliceは、現在のチェーン上のシーケンス番号が5であるアカウントを所有しています。

Aliceはシーケンス番号6のトランザクションをノードBobに送信します。

Bobはトランザクションを受け入れますが、5を確認していないため転送しません。

進行するためには、AliceがBobにトランザクション番号5を送信するか、Bobがコンセンサスから5がコミットされたことを通知される必要があります。後者の場合、Aliceは別のノードを通じてトランザクションを送信したことになります。

これ以外にも、以下の2つの原則があります：

- 単一のアカウントは、最大で100個のコミットされていないトランザクションをブロックチェーンに送信できます。それ以上のトランザクションは拒否されます。これは、Aliceが最初の100個をノードBobに、次の100個をノードCarolに送信した場合、暗黙的に発生する可能性があります。両方のノードが共通のアップストリームを共有している場合、そのアップストリームはBob経由のAliceの100個を受け入れますが、Carol経由のAliceの100個は暗黙的に拒否します。
- 異なるトランザクションを複数のノードに送信すると、送信されたノードは先行するすべてのトランザクションがコミットされたことを知るまでトランザクションを進行させないため、解決が遅くなります。例えば、Aliceが最初の50個をBob経由で、次の50個をCarol経由で送信した場合です。

## トランザクションマネージャーの構築

トランザクションの詳細を理解したところで、堅牢なトランザクションマネージャーの構築について掘り下げましょう。これは以下の主要なコンポーネントで構成されています：

- 単一のアカウントで利用可能なシーケンス番号を割り当て、管理するシーケンス番号ジェネレーター。
- アプリケーションまたはユーザーからペイロードを受け取り、シーケンス番号ジェネレーターからシーケンス番号を受け取り、アカウントキーにアクセスして3つの要素を組み合わせて有効な署名付きトランザクションを作成するトランザクションマネージャー。その後、トランザクションをブロックチェーンにプッシュする責任も負います。
- 複数のアカウントが単一の共有アカウントの署名者を共有できるようにするオンチェーンのワーカー、リーダーハーネス。

現在、このフレームワークは、ネットワークが実質的なキューを構築しないこと、つまり送信されたトランザクションがほとんど遅延なく実行およびコミットされることを前提としています。高需要に対応するために、以下のコンポーネントで作業を拡張する必要があります：

- 優先トランザクションがブロックチェーンにコミットされることを保証するための`base_gas_unit`価格の最適化。
- 有効期限タイマーが適切に設定されるようにするためのトランザクション処理レートのさらなる処理。
- 望ましい結果に基づいて無視または再送信するトランザクション失敗の処理。

注意：アカウントは、トランザクションマネージャーの単一のインスタンスによって管理される必要があります。そうでない場合、トランザクションマネージャーの各インスタンスは古いメモリ内状態を持つ可能性が高く、シーケンス番号が重複する結果となります。

### 実装

- Python
  - [シーケンス番号マネージャー](https://github.com/aptos-labs/aptos-core/pull/7987)
  - [トランザクションマネージャー](https://github.com/aptos-labs/aptos-core/pull/7987)
- [ワーカー・リーダースマートコントラクト](https://github.com/aptos-labs/aptos-core/pull/7986)

### シーケンス番号の管理

各トランザクションには、以前に送信されたトランザクションと連続する個別のシーケンス番号が必要です。これは以下のプロセスで提供できます：

1. 起動時に、アカウントの現在のシーケンス番号をブロックチェーンに問い合わせます。
2. 同時に最大100個のトランザクションを処理中にできます。つまり、コミットが確認されていなくても100個のシーケンス番号を割り当てることができます。
3. 100個のトランザクションが処理中の場合、ネットワークに問い合わせて実際のコミット状態を確認します。これにより現在のシーケンス番号が更新されます。
4. 処理中のトランザクションが100個未満の場合、ステップ2に戻ります。
5. それ以外の場合は、0.1秒スリープして現在のチェーン上のシーケンス番号を再評価し続けます。
6. すべてのトランザクションには有効期限を設定する必要があります。有効期限が過ぎた場合、失敗があったと想定してシーケンス番号をリセットします。単純なケースは、最大数のトランザクションが処理中の場合にのみ失敗を監視し、それ以外の場合は他のサービスにこれを管理させることです。

並行して、新しく送信されたトランザクションを監視します。最も早いトランザクションの有効期限が切れたら、そのトランザクションまで同期します。その後、次のトランザクションに対してプロセスを繰り返します。

失敗が発生した場合は、未処理のトランザクションがすべてタイムアウトするまで待ち、失敗したトランザクションの再生など、アプリケーションが進め方を決定できるようにします。未処理のトランザクションを待つ最良の方法は、台帳のタイムスタンプを照会し、最後のトランザクション送信時刻から最大タイムアウトが経過していることを確認することです。そこから、最後の既知のコミットされたトランザクション以降のすべてのトランザクションがコミットされているか、もはやメンプールに存在しないことをメンプールで検証します。これは、特定のアカウントのトランザクションをREST APIで照会し、現在評価中のシーケンス番号を指定し、制限を1に設定することで実行できます。これらのチェックが完了したら、ローカルのトランザクション番号を再同期できます。

これらの失敗処理手順は、以下の理由で重要です：

- メンプールは期限切れのトランザクションを即座に削除しません。
- 新しいトランザクションは、期限切れであっても既存のトランザクションを上書きできません。
- コンセンサス（つまり台帳のタイムスタンプ）が有効期限を決定し、ローカルノードはトランザクションの有効期限後にコミットされたタイムスタンプを確認し、ガベージコレクションが発生した後にのみ期限切れとなります。

### トランザクションの管理

トランザクションが送信されると、以下のような様々な段階を経ます：

1. RESTエンドポイントへの送信。
2. 送信時のメンプールでの実行前検証。
3. メンプールからメンプールへの送信（各アップストリームノードで実行前検証が行われる）。
4. コンセンサス提案への含有。
5. もう1回の実行前検証。
6. 実行とストレージへのコミット。

考慮すべき多くの潜在的な失敗ケースがあります：

- トランザクション送信時の失敗（1と2）：
  - 可視性：アプリケーションは、ネットワークが利用できないか、トランザクションが実行前検証に失敗したというエラーを受け取ります。
  - エラーが可用性または重複シーケンス番号に関連する場合は、アクセスが可能になり、シーケンス番号が再同期されるまで待ちます。
  - 重複シーケンス番号に関連するもの以外の実行前検証の失敗は現在対象外です。アカウントの問題は、アカウントの無効なキーまたはガス代の不足に関連している可能性があります。
- 送信と実行の間の失敗（3、4、5）：
  - 可視性：トランザクションが期限切れになるまで待つことでのみ判明します。
  - これらは、早期のトランザクションが実行される際のアカウントの変更による他の実行前検証エラーと同じです。重複シーケンス番号またはアカウントのガス代不足の可能性が高いです。
- 実行時の失敗（6）：
  - 可視性：これらはブロックチェーンにコミットされます。
  - これらのエラーはオンチェーン状態の問題により発生します。これらは通常、新しい入札が現在の入札より高くない可能性があるオークションなど、アプリケーション固有のものです。

### ワーカーとアイデンティティ

上記のフレームワークを使用すると、単一のアカウントはブロックの開始から終了までに最大100個のトランザクションをプッシュできます。100個のトランザクションがすべて1ブロック内で消費されると仮定すると、次の100個のスロットが利用可能になるまでに少し時間がかかります。これは、ネットワークの遅延とバリデーターの多段階パイプラインによるものです。

大規模なスループットのためにブロックチェーンを完全に活用するには、単一のユーザーアカウントでは不十分です。代わりに、Aptosはワーカーアカウントの概念をサポートしており、これにより共有アカウント（リソースアカウントとしても知られる）を通じて作業の責任を共有できます。

このモデルでは、各ワーカーは共有アカウントの`SignerCap`にアクセスでき、これにより共有アカウントを偽装したり、共有アカウントの`signer`を生成したりできます。`signer`を取得すると、トランザクションは共有アカウントの署名者によってゲートされているロジックを実行できます。

可能な場合の別のモデルは、`signer`を権限から完全に切り離し、アプリケーション固有の機能を作成することです。その後、この機能を各ワーカーに与えることで、共有インフラストラクチャ上で操作できるようになります。

トランザクションに読み取りまたは書き込みの競合がある場合、共有インフラストラクチャ上の並列化は制限される可能性があることに注意してください。これにより、ブロック内で複数のトランザクションが実行されることは妨げられませんが、ブロックチェーンの最大パフォーマンスに影響を与える可能性があります。
