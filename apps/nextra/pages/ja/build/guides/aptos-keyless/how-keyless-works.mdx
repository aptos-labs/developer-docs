---
title: "キーレスの仕組み"
---
import { YouTube } from "@components/index";

# キーレスの仕組み

Aptos Keylessを使用すると、dAppはOIDCプロバイダー（例：Google）を通じてdAppにサインインしたユーザーのブロックチェーンアカウントを**導出**し**アクセス**することができます。重要なのは、このブロックチェーンアカウントが**dAppに限定**されていることです。つまり、同じOIDCプロバイダーを通じて同じユーザーをサインインできる他のdAppは、このアカウントにアクセスできず、代わりに独自のアカウントを取得します。

_では、これはどのように機能するのでしょうか？_

<YouTube title="キーレスプレゼンテーション" id="sKqeGR4BoI0"/>

## 概要

非常に高いレベルでは、OIDCプロバイダーを通じてdAppへの正常なサインインが行われると、dAppはOIDCプロバイダーによって署名された**JSON Web Token (JWT)**を受け取ります。JWTには、他の情報とともに、3つの重要な情報が含まれています：

1. ユーザーのアイデンティティ（JWTの`sub`フィールドに含まれる）
2. dAppのアイデンティティ（JWTの`aud`フィールドに含まれる）
3. アプリケーション固有のデータ、具体的には、**一時的な公開鍵（EPK）**（JWTの`nonce`フィールドに含まれる）。関連する**一時的な秘密鍵（ESK）**はユーザーのみが知っています。

ここで、ユーザーのブロックチェーンアカウントのアドレスが、上記の`sub`のユーザーアイデンティティと`aud`のdAppアイデンティティのハッシュ（多かれ少なかれ）であると仮定します。

そうすると、**重要な観察点**は、署名されたJWTが実質的に**デジタル証明書**として機能し、このブロックチェーンアドレスをEPKに**一時的に**バインドし、EPKがそのアドレスのトランザクションに署名することを許可するということです。言い換えれば、このブロックチェーンアカウントのトランザクション署名権をEPKに安全に委任します。（注：EPKには有効期限が含まれており、したがって短命です。）

重要なのは、ユーザーがESKを失った場合、OIDCプロバイダーを通じて再度サインインするだけで、新しいEPKに対する新しい署名付きJWTをアプリケーションを通じて取得できることです。（または、場合によっては、OAuthリフレッシュトークンを使用して新しい署名付きJWTをリクエストすることもできます。）

このシステムでは、JWTをオンチェーンで公開するとユーザーのアイデンティティが漏洩するため、**プライバシーを維持すること**が課題となります。さらに、EPKをOIDCプロバイダーに公開すると、ユーザーのオンチェーンでのトランザクションを追跡できるようになってしまいます。

以下では、キーレスアカウントがどのように機能し、これらの課題にどのように対処するかを説明します。

## フロー：dAppでユーザーのキーレスアカウントを導出する

まず、dAppが（例えば）Googleを通じてユーザーをサインインさせ、そのユーザーのキーレスブロックチェーンアドレスを導出し、例えばそのユーザーに資産を送信する方法を見てみましょう。

![キーレスアカウントの図](/docs/aptos-keyless/keyless-account.png "キーレスアカウントの図")

**ステップ1**：ユーザーは一時的なキーペアを生成します：有効期限付きのEPKとそれに関連するESKです。dAppはEPKを保持し、ESKをユーザー側で安全に保存します（例：ブラウザのローカルストレージ、またはESKがWebAuthnパスキーの場合は信頼できるエンクレーブ内）。

**ステップ2**：dAppはEPKを$H(\mathsf{epk}, \rho)$としてコミットします。ここで、$\rho$はブラインディングファクターです。ユーザーが「Googleでサインイン」ボタンをクリックすると、dAppはユーザーをGoogleのサインインページにリダイレクトし、重要なのは、URLの`nonce`パラメータをこのEPKコミットメントに設定することです。これによりEPKがGoogleから隠され、ユーザーのトランザクション活動のプライバシーが維持されます。

**ステップ3**：通常、ユーザーは以前にGoogleアカウントにサインインしたHTTPクッキーを持っているため、Googleはこのクッキーを確認するだけです。ユーザーが複数のGoogleアカウントを持っている場合、GoogleはユーザーにdAppにサインインするアカウントを選択するよう求めます。（より一般的でないパスは、ユーザーがGoogleのユーザー名とパスワードを入力する必要がある場合です。）

**ステップ4**：ユーザーがサインインすると、GoogleはdAppに署名付きJWTを送信します。これには、ユーザーの`sub`識別子（例：`uid-123`）、アプリケーションの`aud`識別子（例：`"dapp-xyz"`）、およびEPKコミットメントを含む`nonce`が含まれます。（これは、dAppが事前にGoogleに登録され、この`"dapp-xyz"`識別子を受け取っていることを前提としています。）

**ステップ5**：dAppは、ユーザーのキーレスアカウントを導出するために必要なほぼすべての情報を持っています：ユーザーの識別子（`sub`）とdAppの識別子（`aud`）です。しかし、ユーザーのプライバシーを保護するために、dAppは3つ目の情報を使用します：**ペッパー**と呼ばれるブラインディングファクター$r$です。dAppは、所謂**ガーディアン**に連絡し、ガーディアンは与えられた（`sub`、`aud`）から決定論的にランダムな$r$を導出します。重要なのは、ガーディアンは、クエリされた（`sub`、`aud`）に対して有効な署名付きJWTを確認した場合にのみ、$r$をdAppに公開することです。

**ステップ6**：dAppはアカウントのアドレスを$\mathsf{addr} = H(\texttt{"uid-123"}, \texttt{"dapp-xyz"}, r)$として導出します。ここで、$H$は暗号化ハッシュ関数です。

ペッパー$r$は、上記で説明したように、有効なJWTを持つ認可されたユーザーのみがこのペッパーを取得できるため、アドレス内のユーザーとアプリのアイデンティティを隠すために使用されることに注意してください。

また、アドレスがEPKとは独立していることにも注意してください。これが、ESKが長期的である必要がなく、失われても構わない理由です。

最後に、dAppは例えば、アドレス$\mathsf{addr}$でユーザーにNFTを送信することができます。

## フロー：キーレスアカウントからトランザクションを送信する

前のフローでは、dAppがプルーバーサービスからZKPを取得する方法を説明しました。次に、dAppがこのZKPを利用してアカウントのトランザクションを行う方法を説明します。

![キーレス署名の図](/docs/aptos-keyless/keyless-signing.png "キーレス署名の図")

**ステップ1**：dAppはユーザーからトランザクションに対する一時的な署名$\sigma_\mathsf{eph}$を取得します。これは、ESKを管理するdApp自身によってユーザーの背後で行われる場合もあれば、ESKがWebAuthnパスキーでユーザーの信頼できるハードウェアに保存されている場合のように、ユーザーに実際の署名リクエストが送信される場合もあります。

**ステップ2**：dAppはトランザクション、ZKP $\pi$、一時的な公開鍵$\mathsf{epk}$、および一時的な署名$\sigma_\mathsf{eph}$をブロックチェーンのバリデータに送信します。

**ステップ3**：トランザクションが有効に署名されているかを確認するために、バリデータは以下の手順を実行します：(1) $\mathsf{epk}$が期限切れでないことを確認、(2) トランザクションからユーザーのアドレス$\mathsf{addr}$を取得、(3) ZKPを$(\mathsf{addr}, \mathsf{epk}, \mathsf{GPK})$に対して検証、(4) トランザクションに対する一時的な署名$\sigma_\mathsf{eph}$を$\mathsf{epk}$に対して検証。これらのすべてのチェックが通過すると、トランザクションを安全に実行できます。
