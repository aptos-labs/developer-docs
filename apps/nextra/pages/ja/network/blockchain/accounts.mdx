---
title: "アカウント"
id: "accounts"
---

import { Callout } from 'nextra/components';

# アカウント

Aptosブロックチェーン上のアカウントは、オンチェーン通貨やNFTなどの一連の資産に対するアクセス制御を表します。Aptosでは、これらの資産はMoveの言語プリミティブである**リソース**として表現され、アクセス制御と希少性の両方が強調されています。

Aptosブロックチェーン上の各アカウントは、32バイトのアカウントアドレスによって識別されます。[www.aptosnames.com](https://www.aptosnames.com/)のAptos Name Serviceを利用して、主要なアカウントに記憶に残る固有の.aptドメインを確保することができます。

他のブロックチェーンではアカウントとアドレスが暗黙的であるのに対し、Aptosのアカウントは明示的で、トランザクションを実行する前に作成する必要があります。アカウントは明示的に作成することも、Aptosトークン（APT）を送金することで暗黙的に作成することもできます。詳細は[アカウントの作成](#creating-an-account)セクションをご覧ください。これは、トランザクションを送信する前にガス代用の資金をアドレスに送る必要がある他のチェーンと似ています。

明示的なアカウントにより、他のネットワークでは利用できない以下のような一級機能が可能になります：

- 認証キーのローテーション。アカウントの認証キーを変更して、異なる秘密鍵で制御することができます。これはweb2の世界でパスワードを変更するのと似ています。
- ネイティブなマルチシグのサポート。Aptosのアカウントは、認証キーを構築する際にEd25519とSecp256k1 ECDSA署名スキームの両方を使用したk-of-nマルチシグをサポートしています。

Aptosには3種類のアカウントがあります：

- _標準アカウント_ - 公開鍵/秘密鍵のペアを持つアドレスに対応する一般的なアカウントです。
- [_リソースアカウント_](../../build/smart-contracts/resource-accounts.mdx) - 開発者がリソースを保存したりモジュールをオンチェーンに公開したりするために使用する、対応する秘密鍵を持たない自律的なアカウントです。
- [_オブジェクト_](../../build/smart-contracts/objects.mdx) - 単一のエンティティを表す単一のアドレス内に保存された複雑なリソースのセットです。

<Callout type="info">
アカウントアドレスは32バイトです。通常、64の16進文字として表示され、各16進文字は4ビットを表します。
アドレスの先頭に0xが付くこともあります。アドレスの表示例については、[初めてのトランザクション](../../build/guides/first-transaction.mdx)をご覧ください。
以下に例を示します：
</Callout>

```text
Alice: 0xeeff357ea5c1a4e7bc11b2b17ff2dc2dcca69750bfef1e1ebcaccf8c8018175b
Bob: 0x19aadeca9388e009d136245b9a67423f3eee242b03142849eb4f81a4a409e59c
```

## アカウントアドレス

現在、Aptosは単一の統一された識別子のみをアカウントに対してサポートしています。Aptosのアカウントは、32バイトの16進文字列として普遍的に表現されます。32バイトより短い16進文字列も有効です。その場合、16進文字列は先頭にゼロを付加することができます（例：`0x1` => `0x0000000000000...01`）。Aptosの標準では、アドレスの先頭のゼロを削除できることを示していますが、ほとんどのアプリケーションはこのレガシーな動作を避け、`0x0`から`0xa`の範囲の特別なアドレスに対してのみ0の削除をサポートしようとしています。

## アカウントの作成

ユーザーがアカウントの作成を要求した場合（例えば[Aptos SDK](../../build/sdks/ts-sdk/account.mdx)を使用して）、以下のステップが実行されます：

- ユーザーのアカウントを管理する認証スキームを選択します（例：Ed25519またはSecp256k1 ECDSA）。
- 新しい秘密鍵と公開鍵のペアを生成します。
- 公開鍵と公開鍵の認証スキームを組み合わせて、32バイトの認証キーとアカウントアドレスを生成します。

ユーザーは、このアカウントに関連するトランザクションの署名に秘密鍵を使用する必要があります。

## アカウントのシーケンス番号

アカウントのシーケンス番号は、そのアカウントからブロックチェーンに送信され、コミットされたトランザクションの数を示します。コミットされたトランザクションは、結果として生じる状態変更がブロックチェーンにコミットされて実行されるか、状態変更が破棄されてトランザクションのみが保存されるかのいずれかです。

送信されるすべてのトランザクションには、送信者のアカウントに対して一意のシーケンス番号が含まれている必要があります。Aptosブロックチェーンがトランザクションを処理する際、トランザクション内のシーケンス番号とオンチェーンアカウントのシーケンス番号を比較します。トランザクションは、シーケンス番号が現在のシーケンス番号以上の場合にのみ処理されます。トランザクションは、現在のシーケンス番号から連続したトランザクションのシリーズがある場合にのみ、他のメモリプールに転送されるか実行されます。実行時には順序外のシーケンス番号を拒否し、古いトランザクションのリプレイ攻撃を防ぎ、将来のトランザクションの順序を保証します。

## 認証キー

初期アカウントアドレスは、アカウント作成時に導出された認証キーに設定されます。ただし、認証キーは後で変更される可能性があります（例：新しい公開鍵と秘密鍵のペア、キーをローテーションするための公開鍵を生成した場合）。アカウントアドレスは決して変更されません。

Aptosブロックチェーンは以下の認証スキームをサポートしています：

1. [Ed25519](https://ed25519.cr.yp.to/)
2. [Secp256k1 ECDSA](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-49.md)
3. [K-of-N マルチシグネチャ](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-55.md)
4. 専用の（現在はレガシーな）MultiEd25519スキーム

<Callout type="info">
AptosブロックチェーンはデフォルトでEd25519署名トランザクションを使用します。
</Callout>

### Ed25519認証

Ed25519署名の認証キーとアカウントアドレスを生成するには：

1. **キーペアの生成**: 新しいキーペア（`privkey_A`、`pubkey_A`）を生成します。AptosブロックチェーンはRFC 8032で定義されているEd25519曲線上のPureEdDSAスキームを使用します。
2. **32バイトの認証キーの導出**: `pubkey_A`から32バイトの認証キーを導出します：
   ```text
   auth_key = sha3-256(pubkey_A | 0x00)
   ```
   ここで`|`は連結を表します。`0x00`は1バイトの単一署名スキーム識別子です。
3. この初期認証キーを永続的なアカウントアドレスとして使用します。

### MultiEd25519認証

K-of-N マルチシグ認証では、アカウントに対してN人の署名者が存在し、トランザクションを認証するためにはそのN人のうち少なくともK人の署名が必要です。

K-of-N マルチシグアカウントの認証キーとアカウントアドレスを生成するには：

1. **キーペアの生成**: `N`個のed25519公開鍵`p_1`、...、`p_n`を生成します。
2. トランザクションの認証に必要な署名数のしきい値`K`を決定します。
3. **32バイトの認証キーの導出**: 以下のように認証キーを計算します：
   ```text
   auth_key = sha3-256(p_1 | . . . | p_n | K | 0x01)
   ```
   `0x01`は1バイトのマルチシグスキーム識別子です。
4. この初期認証キーを永続的なアカウントアドレスとして使用します。

### 一般化された認証

一般化された認証は、Ed25519とSecp256k1 ECDSAの両方をサポートします。前述の認証スキームと同様に、これらのスキームにはスキーム値（単一キーの場合は`0x02`、マルチキーの場合は`0x03`）が含まれますが、各キーにはそのキータイプを示すプレフィックス値も含まれます：

| キータイプ                         | プレフィックスバイト |
|-----------------------------------|-------------|
| Ed25519一般化スキーム              | `0x00`      |
| Secp256k1Ecdsa一般化スキーム       | `0x01`      |
| Secp256r1Ecdsa WebAuthnスキーム    | `0x02`      |
| キーレス                           | `0x03`      |

単一キーのSecp256k1 ECDSAアカウントの場合、公開鍵`pubkey`を使用して、認証キーは以下のように導出されます：

```text
auth_key = sha3-256(0x01 | pubkey | 0x02)
```

ここで、

- 最初のエントリ `0x01` は、Secp256k1 ECDSAキーの使用を表します。
- 最後のエントリ `0x02` は、認証スキームを表します。

1つのSecp256k1 ECDSA公開鍵 `pubkey_0` と1つのEd25519公開鍵 `pubkey_1` を含む1-of-2マルチキーアカウントで、
1つの署名で十分な場合、認証キーは以下のように導出されます：

```text
auth_key = sha3-256(0x02 | 0x01 | pubkey_0 | 0x00 | pubkey_1 | 0x01 | 0x03)
```

ここで、

- 最初のエントリ `0x02` は、キーの総数を1バイトで表します。
- 最後から2番目のエントリ `0x01` は、必要な署名数を1バイトで表します。
- 最後のエントリ `0x03` は、認証スキームを表します。

## キーのローテーション

Aptosのアカウントは、キーをローテーション（更新）する機能を持っています。これにより、漏洩した可能性のあるキーをアカウントへのアクセスに使用できないようにすることができます。キーは `account::rotate_authentication_key` 関数を使用してローテーションできます。

キーの更新はセキュリティ分野では一般的に良い習慣とされています。ただし、ニーモニックを使用して秘密鍵とそれに関連するアカウントの両方を表現することに慣れているシステム統合者にとっては、これは課題となります。これを簡素化するために、Aptosは `aptos account lookup-address` を介してオンチェーンマッピングを提供しています。このオンチェーンデータは、現在のニーモニックによって定義される有効なアカウントアドレスを実際のアカウントアドレスにマッピングします。

詳細については、[`account.move`](https://github.com/aptos-labs/aptos-core/blob/a676c1494e246c31c5e96d3363d99e2422e30f49/aptos-move/framework/aptos-framework/sources/account.move#L274)をご覧ください。

## アカウントの状態

各アカウントの状態は、コード（Moveモジュール）とデータ（Moveリソース）の両方で構成されています。アカウントには任意の数のMoveモジュールとMoveリソースを含めることができます：

- **Moveモジュール**: Moveモジュールにはコードが含まれています（例：型と手続きの宣言）が、データは含まれていません。Moveモジュールは、Aptosブロックチェーンのグローバル状態を更新するためのルールをエンコードします。
- **Moveリソース**: Moveリソースにはデータが含まれていますが、コードは含まれていません。すべてのリソース値には、Aptosブロックチェーンに公開されているモジュールで宣言された型があります。

## signerによるアクセス制御

トランザクションの送信者は、signerによって表されます。Moveモジュールの関数が `signer` を引数として取る場合、Aptos Move VMはトランザクションに署名したアカウントのIDを、Moveモジュールのエントリーポイントのsignerに変換します。以下のMoveコード例では、`initialize` と `withdraw` 関数で `signer` を使用しています。`deposit` 関数のように関数で `signer` が指定されていない場合、その関数にはsignerベースのアクセス制御は提供されません：

```move filename="coin.move" /account: &signer/
module Test::Coin {
  struct Coin has key { amount: u64 }

  public fun initialize(account: &signer) {
    move_to(account, Coin { amount: 1000 });
  }

  public fun withdraw(account: &signer, amount: u64): Coin acquires Coin {
    let balance = &mut borrow_global_mut<Coin>(Signer::address_of(account)).amount;
    *balance = *balance - amount;
    Coin { amount }
  }

  public fun deposit(account: address, coin: Coin) acquires Coin {
      let balance = &mut borrow_global_mut<Coin>(account).amount;
      *balance = *balance + coin.amount;
      Coin { amount: _ } = coin;
  }
}
```
